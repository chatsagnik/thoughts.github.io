<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>$q$-ary Lattices | Theoretickles</title><meta name=keywords content="lattices,coding theory,cryptography"><meta name=description content="In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.
Hardness of problems
Computational hardness usually revolves around problems with worst-case hardness guarantees since we want to design algorithms that run efficiently even on the worst possible input.
On the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with average-case hardness guarantees."><meta name=author content="Me"><link rel=canonical href=https://theoretickles.netlify.app/posts/qary/><link crossorigin=anonymous href=/assets/css/stylesheet.242f90366e47418aeeb4469f46a06be27f005e2845b0e27a538c5a6d413c453d.css integrity="sha256-JC+QNm5HQYrutEafRqBr4n8AXihFsOJ6U4xabUE8RT0=" rel="preload stylesheet" as=style><link rel=icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://theoretickles.netlify.app/posts/qary/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript id=MathJax-script async src=https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://theoretickles.netlify.app/posts/qary/"><meta property="og:site_name" content="Theoretickles"><meta property="og:title" content="$q$-ary Lattices"><meta property="og:description" content="In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.
Hardness of problems Computational hardness usually revolves around problems with worst-case hardness guarantees since we want to design algorithms that run efficiently even on the worst possible input.
On the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with average-case hardness guarantees."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-01T12:03:46+05:30"><meta property="article:modified_time" content="2025-04-01T12:03:46+05:30"><meta property="article:tag" content="Lattices"><meta property="article:tag" content="Coding Theory"><meta property="article:tag" content="Cryptography"><meta property="og:image" content="https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="$q$-ary Lattices"><meta name=twitter:description content="In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.
Hardness of problems
Computational hardness usually revolves around problems with worst-case hardness guarantees since we want to design algorithms that run efficiently even on the worst possible input.
On the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with average-case hardness guarantees."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://theoretickles.netlify.app/posts/"},{"@type":"ListItem","position":2,"name":"$q$-ary Lattices","item":"https://theoretickles.netlify.app/posts/qary/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"$q$-ary Lattices","name":"$q$-ary Lattices","description":"In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.\nHardness of problems Computational hardness usually revolves around problems with worst-case hardness guarantees since we want to design algorithms that run efficiently even on the worst possible input.\nOn the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with average-case hardness guarantees.\n","keywords":["lattices","coding theory","cryptography"],"articleBody":"In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.\nHardness of problems Computational hardness usually revolves around problems with worst-case hardness guarantees since we want to design algorithms that run efficiently even on the worst possible input.\nOn the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with average-case hardness guarantees.\nHowever, it is not immediately apparent how to create hard instances of problems with worst-case hardness guarantees. In other words, how to design the most secure keys for cryptographic applications is unclear.\nAny random instance of a problem with average-case hardness guarantee is hard with a positive probability. Suppose one could show that such a random instance is as hard as the hardest instance (a reduction from average-case hardness to worst-case hardness). In that case, such a reduction immediately lends itself to applications in cryptography. This reduction is precisely the central thesis of the seminal work Ajtai'96 1.\nLattice-based Cryptography What is a Lattice? A Lattice $\\Lambda$ or $\\mathcal{L}$ is defined as the set of all integer linear combinations of $n$ linearly independent $m$-dimensional vectors $B=\\{\\mathrm{b_1},\\mathrm{b_2},\\ldots,\\mathrm{b_n}\\}$. Formally, we denote lattices as $$\\mathcal{L}(B)=\\left\\{Bx, x\\in\\mathbb{Z}^{m}\\right\\}=\\left\\{\\sum_{i=1}^{n}x_i\\mathrm{b_i} : x_i\\in\\mathbb{Z}\\right\\}.$$\nThe set $B\\in\\mathbb{R}^{n\\times m}$ is said to be the basis of the lattice $\\Lambda$. We note here that any lattice $\\Lambda$ is characterized by its basis. Shortly, we will generalize the definition of lattices by showing a different characterization of lattices which will be useful in cryptographic construction schemes.\nWhy do we need Lattice-based Cryptography? Ajtai'96 1 showed reductions from lattice based problems with average-case hardness guarantees to lattice problems with worst-case guarantees.\nLet $P$ be the class of lattice based problems defined in Ajtai'96 1. Then, the above reduction implies that any randomly sampled instance of $P$ is as computationally hard to solve as the hardest instance in $P$.\nFor reasons discussed above, this immediately makes lattices an extremely important tool in cryptography. In fact, lattice based cryptographic constructions are invaluable for their many potential advantages as follows:\nLattice-based schemes usually only require linear operations on integers which leads to asymptotic efficiency. Lattice-based schemes have been shown to be resistant to cryptanalysis by quantum algorithms unlike current classical cryptographic schemes which are based on factoring or discrete log (Shor'95 2). This makes lattice-based cryptography the cornerstone of post-quantum cryptography. As noted earlier, random instances of lattice based constructions are “as hard as possible”, which lends itself to conceptual simplicity while designing cryptographic schemes. Hard Lattice problems w/ known worst-case hardness guarantees In this section, we discuss a few lattice problems with known worst-case hardness guarantees.\nShortest Vector Problem $\\left(\\mathrm{SVP}_\\gamma\\right)$ In the $\\gamma$-approximate Shortest Vector Problem, we are asked find the length of the shortest non-zero vector (denoted by $\\lambda_1$) in an $n$-dimensional lattice, approximately, up to a polynomial factor $\\gamma$.\nIt is known that the approximate (and also decision) SVP is NP-hard under a randomized reduction.3 Shortest Independent Vector Problem $\\left(\\mathrm{SIVP}_\\gamma\\right)$ The goal of the $\\gamma$-approximate Shortest Independent Vector problem is to output a set of $n$ linearly independent lattice vectors in an $n$-dimensional lattice, approximately of length$\\leq\\gamma\\lambda_n$.\nSIVP is NP-hard to approximate for any constant approximation factor.4 Shortest Basis Problem $\\left(\\mathrm{SBP}_\\gamma\\right)$ The $\\gamma$-approximate Shortest Basis Problem asks us to find a basis $B={\\mathrm{b_1},\\mathrm{b_2},\\ldots,\\mathrm{b_n}}$ for an $n$-dimensional lattice $\\mathcal{L}(B)$ such that $\\mathrm{max}_i \\lVert\\mathrm{b_i}\\rVert$ is the smallest possible upto a factor of $\\gamma$.\nLater in this post we will see the connection between the above problems.\nConstructing random instances of a Hard Lattice problem In this section, we show a reduction from randomly generated lattices to instances of one of these problems. We now state some important results from Ajtai'961 and Ajtai'995 which deal with the construction of random instances of hard lattice problems. The following lemma shows that hardness of SBP by reduction to SVP.\nLemma 1 (Ajtai'96) If $\\mathrm{SBP}_\\gamma$ has no polynomial time solution for $\\gamma=\\mathrm{poly}(n)$, then we can generate a random lattice $\\Lambda$ (over some distribution $\\mathcal{D}$) together with a “short” vector $x\\in\\Lambda$ in polynomial time s.t. there is no algorithm which can find a vector shorter than $\\sqrt{n}$ in $\\Lambda$ over $\\mathcal{D}$ w.p. greater than $n^{-c}$, for sufficiently large $n$ and any $c\u003e0$.\nNote: Here “short’’ refers to $|x|\\leq\\sqrt{n}$. Later Ajtai'99 5 extended Lemma 1 to the following theorem:\nTheorem 2 (Main Theorem, Ajtai'99) If $\\mathrm{SBP}_\\gamma$ has no polynomial time solution for $\\gamma=\\mathrm{poly}(n)$, then we can generate a random lattice $\\Lambda$ (from the same distribution $\\mathcal{D}$ as in Lemma 1 together with a “short” basis $B$ of $\\Lambda$ in polynomial time s.t. there is no algorithm which can find a vector shorter than $\\sqrt{n}$ in $\\Lambda$ over $\\mathcal{D}$ w.p. greater than $n^{-c}$, for sufficiently large $n$ and any $c\u003e0$.\nAs we see, Theorem 2 clearly gives us a way to construct a random instance of a hard problem ($\\mathrm{SBP}_\\gamma$). A short basis means $\\lVert \\mathrm{b_i} \\rVert\\leq n\\sqrt{n},i\\in[n]$, where $B=\\{\\mathrm{b_1},\\mathrm{b_2},\\ldots,\\mathrm{b_n}\\}$. In the next, we concretely define the class of “random” lattices required by the above results.\nThe SIS problem In this section, we take a deeper dive into the special class of random lattices given by Ajtai'961, where it was shown how to\nConstruct a family of one-way functions (based on the earlier family of random lattices as seen in Lemma 1), s.t., If we invert any function from this family of functions with non-negligible probability, it implies that we can solve any instance of the $\\mathrm{SVP}_\\gamma$ for $\\gamma=O({n^c}),c\u003e1$. Therefore, by the previous discussion, we see that the above construction implies an average-case to worst-case reduction. GGH116 later extended the analysis of Ajtai96 to show that the family of one-way functions is also collision-resistant, which is a stronger and more useful property for cryptographic applications.\nWe now define the SIS problem and state a lemma (without proof) of its hardness.\nShort Integer Solution ($\\mathrm{SIS}_{n,m,q,\\beta}$) Let $A$ be a uniformly random matrix , i.e. , $A=\\{a_0| a_1 | \\ldots | a_{m-1}\\}$ consists of $m$ uniformly random vectors $a_i\\in\\mathbb{Z}^n_q,i\\in[m]$. Find a nontrivial $x\\in\\mathbb{Z}^m$, s.t. $|x|\\leq\\beta$ and $Ax\\equiv 0\\mod{q}$.\nHere $A\\sim\\mathbb{Z}_{q}^{n\\times m}$ where $\\mathbb{Z}^n_q$ is the set of all $n$-dimensional integer vectors modulo $q$, i.e., $\\mathbb{Z}^n_q={\\left\\langle x_1,\\ldots, x_n \\right\\rangle}$, where $x_i\\in{0,1,\\ldots,q-1}$ for all $i\\in[n]$.\nWe also note here that without the constraint $|x|\\leq\\beta$, the $\\mathrm{SIS}$ is easy to solve using Gaussian elimination.\nHardness of $\\mathrm{SIS}$ For any $m = \\mathrm{poly}(n)$, any $\\beta \u003e 0$, and any sufficiently large $q \\geq \\beta n^c$ (for any constant $c \u003e0$), solving $\\mathrm{SIS}({n,m,q,\\beta})$ with nonnegligible probability is at least as hard as solving $GapSVP_\\gamma$ and ${SIVP}_\\gamma$ for some $\\gamma = \\beta \\cdot O(\\sqrt{n})$ with a high probability in the worst-case scenario.\nNow we turn our attention to the construction of GGH116 based on the hardness of $\\mathrm{SIS}$.\nA specific CRHF construction (GGH11) We define a Collision-Resistant Hash function (CRHF) as follows:\nSet $m\u003en\\frac{\\log{q}}{\\log{d}}$. Key: A matrix $A$ chosen uniformly at random from $\\mathbb{Z}^{m\\times n}_q$. Hash function: Define a Shrinking function (shrinking since the domain is greater than the range): $f_A:{0,\\ldots, d-1}^m\\xrightarrow{}\\mathbb{Z}^n_q$ s.t. $f_A(x)=Ax\\mod q$. Goal: Find $x,x^{\\prime}\\in{0,1}^m$ s.t. $f_A(x)=f_A(x^{\\prime})$. Note that finding a solution to the collision problem yields a solution $z=x-x^\\prime$ to the $\\mathrm{SIS}$ problem as $0=f_A(x)-f_A(x^{\\prime})=Ax-Ax^\\prime=Az\\equiv 0\\mod{q}$.\nWe now define a class of random lattices known as $q$-ary lattices and connect it to the $\\mathrm{SIS}$ problem.\n$q$-ary Lattices at last! Given $A\\sim \\mathbb{Z}^{n\\times m}_q$, $q$-ary lattices $\\Lambda_q^\\perp(A)$ are defined as $$\\Lambda_q^\\perp(A)=\\{z\\in\\mathbb{Z}^m:Az=0\\mod{q}\\}.$$\nWe note that the randomness of $\\Lambda_q^\\perp(A)$ stems from the randomness of $A$ itself. $\\Lambda_q^\\perp(A)$ contains all vectors that are orthogonal modulo $q$ to the rows of $A$, i.e. $\\Lambda_q^\\perp(A)$ corresponds to the code whose parity check matrix is $A$.\nHere, we see that we have successfully characterized a lattice in terms of a parity check matrix $A$ instead of a basis. The class of $q$-ary lattices is the class of random lattices required in Lemma 1 and Theorem 2. We end this article with another lemma by Ajtai96 and some properties of $q$-ary lattices which connects the average-case hardness guarantees with worst-case guarantees.\nLemma 2 (Ajtai96) Finding short $z\\in\\Lambda_q^\\perp(A)$ s.t. $\\left|{z}\\right|\\leq \\beta \u003c q$, implies solving $\\mathrm{GapSVP}_{\\beta\\sqrt{n}}$ on any n-dimensional lattice.\nProperties of $q$-ary Lattices A $q$-ary lattice $L$ satisfies $q\\mathbb{Z}^n \\subseteq L \\subseteq \\mathbb{Z}^n$ for $q\\in\\mathbb{Z}$. Any integer lattice $\\mathcal{L}\\subseteq\\mathbb{Z}^n$ is a $q$-ary lattice for some $q$, e.g., whenever q is an integer multiple of the determinant $\\mathrm{det}(\\mathcal{L})$. We are only interested when $q$ is much smaller than $\\left|{\\mathrm{det}(L)}\\right|$. The following two problems are equivalent: Finding a short vector in $\\Lambda_q^\\perp(A)$ s.t. $A\\sim \\mathbb{Z}^{n\\times m}_q$. Finding a short solution to a set of $n$ random equations modulo $q$ in $m$ variables. The dual of any $q$-ary lattice is also a $q$-ary lattice. We represent the dual of a $q$-ary lattice $\\Lambda_q^\\perp(A)$ using the notation $\\Lambda_q(A)$, which is defined as $$\\Lambda_q(A)=\\{z\\in\\mathbb{Z}^m:z=A^Ts\\mod{q},,s\\in\\mathbb{Z}^n\\}.$$ Here $\\Lambda_q(A)$ is the code generated by the rows of $A$, i.e., $A$ itself is the generator matrix of the code. Contrast this with $\\Lambda_q^\\perp(A)$ where $A$ is the parity check matrix. References Ajtai96: M. Ajtai. 1996. Generating hard instances of lattice problems (extended abstract). In Proceedings of the twenty-eighth annual ACM symposium on Theory of Computing (STOC ‘96). Association for Computing Machinery, New York, NY, USA, 99–108. https://doi.org/10.1145/237814.237838\r↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nShor95: Peter W. Shor. 1997. Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer. SIAM J. Comput. 26, 5 (Oct. 1997), 1484–1509. https://doi.org/10.1137/S0097539795293172\r↩︎\nBP23: Huck Bennett and Chris Peikert. Hardness of the (Approximate) Shortest Vector Problem: A Simple Proof via Reed-Solomon Codes. In Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques (APPROX/RANDOM 2023). Leibniz International Proceedings in Informatics (LIPIcs), Volume 275, pp. 37:1-37:20, Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2023). https://doi.org/10.4230/LIPIcs.APPROX/RANDOM.2023.37\r↩︎\nBS99: Johannes Blömer and Jean-Pierre Seifert. On the complexity of computing short linearly independent vectors and short bases in a lattice. In Proceedings of the Thirty-first Annual ACM Symposium on Theory of Computing, STOC ’99, pages 711–720, New York, NY, USA, 1999. ACM. ↩︎\nAjtai99: Miklós Ajtai. 1999. Generating Hard Instances of the Short Basis Problem. In Proceedings of the 26th International Colloquium on Automata, Languages and Programming (ICAL ‘99). Springer-Verlag, Berlin, Heidelberg, 1–9. ↩︎ ↩︎\nGGH11: O. Goldreich, S. Goldwasser, and S. Halevi. Collision-free hashing from lattice problems. Studies in Complexity and Cryptography. Miscellanea on the Interplay between Randomness and Computation: In Collaboration with Lidor Avigad, Mihir Bellare, Zvika Brakerski, Shafi Goldwasser, Shai Halevi, Tali Kaufman, Leonid Levin, Noam Nisan, Dana Ron, Madhu Sudan, Luca Trevisan, Salil Vadhan, Avi Wigderson, David Zuckerman, pages 30–39, 2011 ↩︎ ↩︎\n","wordCount":"1736","inLanguage":"en","image":"https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-04-01T12:03:46+05:30","dateModified":"2025-04-01T12:03:46+05:30","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://theoretickles.netlify.app/posts/qary/"},"publisher":{"@type":"Organization","name":"Theoretickles","logo":{"@type":"ImageObject","url":"https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://theoretickles.netlify.app/ accesskey=h title="Theoretickles (Alt + H)"><img src=https://theoretickles.netlify.app/apple-touch-icon.png alt aria-label=logo height=35>Theoretickles</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://theoretickles.netlify.app/categories/ title=categories><span>categories</span></a></li><li><a href=https://theoretickles.netlify.app/tags/ title=tags><span>tags</span></a></li><li><a href=https://chatsagnik.github.io title=chatsagnik><span>chatsagnik</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://theoretickles.netlify.app/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://theoretickles.netlify.app/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://theoretickles.netlify.app/>Home</a>&nbsp;»&nbsp;<a href=https://theoretickles.netlify.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">$q$-ary Lattices</h1><div class=post-meta><span title='2025-04-01 12:03:46 +0530 IST'>April 1, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1736 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/qary.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#hardness-of-problems aria-label="Hardness of problems">Hardness of problems</a></li></ul><li><a href=#lattice-based-cryptography aria-label="Lattice-based Cryptography">Lattice-based Cryptography</a><ul><li><a href=#what-is-a-lattice aria-label="What is a Lattice?">What is a Lattice?</a></li><li><a href=#why-do-we-need-lattice-based-cryptography aria-label="Why do we need Lattice-based Cryptography?">Why do we need Lattice-based Cryptography?</a></li><li><a href=#hard-lattice-problems-w-known-worst-case-hardness-guarantees aria-label="Hard Lattice problems w/ known worst-case hardness guarantees">Hard Lattice problems w/ known worst-case hardness guarantees</a><ul><li><a href=#shortest-vector-problem-leftmathrmsvp_gammaright aria-label="Shortest Vector Problem $\left(\mathrm{SVP}_\gamma\right)$">Shortest Vector Problem $\left(\mathrm{SVP}_\gamma\right)$</a></li><li><a href=#shortest-independent-vector-problem-leftmathrmsivp_gammaright aria-label="Shortest Independent Vector Problem $\left(\mathrm{SIVP}_\gamma\right)$">Shortest Independent Vector Problem $\left(\mathrm{SIVP}_\gamma\right)$</a></li><li><a href=#shortest-basis-problem-leftmathrmsbp_gammaright aria-label="Shortest Basis Problem $\left(\mathrm{SBP}_\gamma\right)$">Shortest Basis Problem $\left(\mathrm{SBP}_\gamma\right)$</a></li></ul></li><li><a href=#constructing-random-instances-of-a-hard-lattice-problem aria-label="Constructing random instances of a Hard Lattice problem">Constructing random instances of a Hard Lattice problem</a><ul><li><a href=#lemma-1-ajtai96 aria-label="Lemma 1 (Ajtai'96)">Lemma 1 (Ajtai'96)</a></li><li><a href=#theorem-2-main-theorem-ajtai99 aria-label="Theorem 2 (Main Theorem, Ajtai'99)">Theorem 2 (Main Theorem, Ajtai'99)</a></li></ul></li><li><a href=#the-sis-problem aria-label="The SIS problem">The SIS problem</a></li><li><a href=#short-integer-solution-mathrmsis_nmqbeta aria-label="Short Integer Solution ($\mathrm{SIS}_{n,m,q,\beta}$)">Short Integer Solution ($\mathrm{SIS}_{n,m,q,\beta}$)</a><ul><li><a href=#hardness-of-mathrmsis aria-label="Hardness of $\mathrm{SIS}$">Hardness of $\mathrm{SIS}$</a></li><li><a href=#a-specific-crhf-construction-ggh11 aria-label="A specific CRHF construction (GGH11)">A specific CRHF construction (GGH11)</a></li></ul></li><li><a href=#q-ary-lattices-at-last aria-label="$q$-ary Lattices at last!">$q$-ary Lattices at last!</a><ul><li><a href=#lemma-2-ajtai96 aria-label="Lemma 2 (Ajtai96)">Lemma 2 (Ajtai96)</a></li><li><a href=#properties-of-q-ary-lattices aria-label="Properties of $q$-ary Lattices">Properties of $q$-ary Lattices</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>In this post, we discuss an important class of algebraic structures known as $q$-ary lattices that are central to lattice-based cryptographic primitives.</p><h2 id=hardness-of-problems>Hardness of problems<a hidden class=anchor aria-hidden=true href=#hardness-of-problems>#</a></h2><p>Computational hardness usually revolves around problems with <strong>worst-case hardness</strong> guarantees since we want to design algorithms that run efficiently even on the worst possible input.</p><p>On the other hand, cryptographic schemes require security guarantees for random keys. Therefore, cryptographic applications require problems with <strong>average-case hardness</strong> guarantees.</p><p>However, it is not immediately apparent <strong>how to create hard instances of problems</strong> with worst-case hardness guarantees. In other words, how to design the most secure keys for cryptographic applications is unclear.</p><p>Any random instance of a problem with <strong>average-case hardness</strong> guarantee <strong>is hard</strong> with a positive probability. Suppose one could show that such a random instance is as hard as the hardest instance (a reduction from average-case hardness to worst-case hardness). In that case, such a reduction immediately lends itself to applications in cryptography. This reduction is precisely the central thesis of the seminal work Ajtai'96 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><h1 id=lattice-based-cryptography>Lattice-based Cryptography<a hidden class=anchor aria-hidden=true href=#lattice-based-cryptography>#</a></h1><h2 id=what-is-a-lattice>What is a Lattice?<a hidden class=anchor aria-hidden=true href=#what-is-a-lattice>#</a></h2><blockquote><p>A Lattice $\Lambda$ or $\mathcal{L}$ is defined as the set of all integer linear combinations of $n$ linearly independent $m$-dimensional vectors $B=\{\mathrm{b_1},\mathrm{b_2},\ldots,\mathrm{b_n}\}$.
Formally, we denote lattices as
$$\mathcal{L}(B)=\left\{Bx, x\in\mathbb{Z}^{m}\right\}=\left\{\sum_{i=1}^{n}x_i\mathrm{b_i} : x_i\in\mathbb{Z}\right\}.$$</p></blockquote><p>The set $B\in\mathbb{R}^{n\times m}$ is said to be the basis of the lattice $\Lambda$. We note here that <strong>any lattice $\Lambda$ is characterized by its basis</strong>. Shortly, we will <em>generalize the definition of lattices</em> by showing a different characterization of lattices which will be useful in cryptographic construction schemes.</p><h2 id=why-do-we-need-lattice-based-cryptography>Why do we need Lattice-based Cryptography?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-lattice-based-cryptography>#</a></h2><p>Ajtai'96 <sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> showed <strong>reductions</strong> from <strong>lattice based problems</strong> with <em>average-case hardness</em> guarantees to lattice problems with <em>worst-case guarantees</em>.</p><blockquote><p>Let $P$ be the class of lattice based problems defined in Ajtai'96 <sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Then, the above reduction implies that any randomly sampled instance of $P$ is as computationally hard to solve as the hardest instance in $P$.</p></blockquote><p>For reasons discussed above, this immediately makes lattices an extremely important tool in cryptography. In fact, lattice based cryptographic constructions are invaluable for their many potential advantages as follows:</p><ol><li>Lattice-based schemes usually <strong>only require linear operations on integers</strong> which leads to asymptotic efficiency.</li><li>Lattice-based schemes have been shown to be <strong>resistant to cryptanalysis by quantum algorithms</strong> unlike current classical cryptographic schemes which are based on factoring or discrete log (Shor'95 <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>). This makes lattice-based cryptography the cornerstone of post-quantum cryptography.</li><li>As noted earlier, random instances of lattice based constructions are “<em>as hard as possible</em>”, which lends itself to <strong>conceptual simplicity</strong> while designing cryptographic schemes.</li></ol><h2 id=hard-lattice-problems-w-known-worst-case-hardness-guarantees>Hard Lattice problems w/ known worst-case hardness guarantees<a hidden class=anchor aria-hidden=true href=#hard-lattice-problems-w-known-worst-case-hardness-guarantees>#</a></h2><p>In this section, we discuss a few lattice problems with <strong>known worst-case hardness guarantees</strong>.</p><h3 id=shortest-vector-problem-leftmathrmsvp_gammaright>Shortest Vector Problem $\left(\mathrm{SVP}_\gamma\right)$<a hidden class=anchor aria-hidden=true href=#shortest-vector-problem-leftmathrmsvp_gammaright>#</a></h3><p>In the $\gamma$-approximate Shortest Vector Problem, we are asked find the length of the shortest non-zero vector (denoted by $\lambda_1$) in an $n$-dimensional lattice, approximately, up to a polynomial factor $\gamma$.</p><ul><li>It is known that the approximate (and also decision) SVP is <strong>NP-hard</strong> under a randomized reduction.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ul><h3 id=shortest-independent-vector-problem-leftmathrmsivp_gammaright>Shortest Independent Vector Problem $\left(\mathrm{SIVP}_\gamma\right)$<a hidden class=anchor aria-hidden=true href=#shortest-independent-vector-problem-leftmathrmsivp_gammaright>#</a></h3><p>The goal of the $\gamma$-approximate Shortest Independent Vector problem is to output a set of $n$ linearly independent lattice vectors in an $n$-dimensional lattice, approximately of length$\leq\gamma\lambda_n$.</p><ul><li>SIVP is <strong>NP-hard</strong> to approximate for any constant approximation factor.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></li></ul><h3 id=shortest-basis-problem-leftmathrmsbp_gammaright>Shortest Basis Problem $\left(\mathrm{SBP}_\gamma\right)$<a hidden class=anchor aria-hidden=true href=#shortest-basis-problem-leftmathrmsbp_gammaright>#</a></h3><p>The $\gamma$-approximate Shortest Basis Problem asks us to find a basis $B={\mathrm{b_1},\mathrm{b_2},\ldots,\mathrm{b_n}}$ for an $n$-dimensional lattice $\mathcal{L}(B)$ such that $\mathrm{max}_i \lVert\mathrm{b_i}\rVert$ is the smallest possible upto a factor of $\gamma$.</p><p>Later in this post we will see the connection between the above problems.</p><h2 id=constructing-random-instances-of-a-hard-lattice-problem>Constructing random instances of a Hard Lattice problem<a hidden class=anchor aria-hidden=true href=#constructing-random-instances-of-a-hard-lattice-problem>#</a></h2><p>In this section, we show a reduction from randomly generated lattices to instances of one of these problems.
We now state some important results from Ajtai'96<sup id=fnref3:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and Ajtai'99<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> which deal with the construction of random instances of hard lattice problems. The following lemma shows that hardness of SBP by reduction to SVP.</p><h3 id=lemma-1-ajtai96>Lemma 1 (Ajtai'96)<a hidden class=anchor aria-hidden=true href=#lemma-1-ajtai96>#</a></h3><blockquote><p>If $\mathrm{SBP}_\gamma$ has no polynomial time solution for $\gamma=\mathrm{poly}(n)$, then we can generate a random lattice $\Lambda$ (over some distribution $\mathcal{D}$) together with a &ldquo;short&rdquo; vector $x\in\Lambda$ in polynomial time s.t. there is no algorithm which can find a vector shorter than $\sqrt{n}$ in $\Lambda$ over $\mathcal{D}$ w.p. greater than $n^{-c}$, for sufficiently large $n$ and any $c>0$.</p></blockquote><p><strong>Note:</strong> Here &ldquo;short&rsquo;&rsquo; refers to $|x|\leq\sqrt{n}$. Later Ajtai'99 <sup id=fnref1:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> extended <strong>Lemma 1</strong> to the following theorem:</p><h3 id=theorem-2-main-theorem-ajtai99>Theorem 2 (Main Theorem, Ajtai'99)<a hidden class=anchor aria-hidden=true href=#theorem-2-main-theorem-ajtai99>#</a></h3><blockquote><p>If $\mathrm{SBP}_\gamma$ has no polynomial time solution for $\gamma=\mathrm{poly}(n)$, then we can generate a random lattice $\Lambda$ (from the same distribution $\mathcal{D}$ as in <strong>Lemma 1</strong> together with a &ldquo;short&rdquo; basis $B$ of $\Lambda$ in polynomial time s.t. there is no algorithm which can find a vector shorter than $\sqrt{n}$ in $\Lambda$ over $\mathcal{D}$ w.p. greater than $n^{-c}$, for sufficiently large $n$ and any $c>0$.</p></blockquote><p>As we see, <strong>Theorem 2</strong> clearly gives us a way to <strong>construct a random instance of a hard problem</strong> ($\mathrm{SBP}_\gamma$). A short basis means $\lVert \mathrm{b_i} \rVert\leq n\sqrt{n},i\in[n]$, where $B=\{\mathrm{b_1},\mathrm{b_2},\ldots,\mathrm{b_n}\}$. In the next, we concretely define the class of &ldquo;random&rdquo; lattices required by the above results.</p><h2 id=the-sis-problem>The SIS problem<a hidden class=anchor aria-hidden=true href=#the-sis-problem>#</a></h2><p>In this section, we take a deeper dive into the special class of random lattices given by Ajtai'96<sup id=fnref4:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, where it was shown how to</p><ul><li>Construct a family of one-way functions (based on the earlier family of random lattices as seen in Lemma 1), s.t.,</li><li>If we invert any function from this family of functions with non-negligible probability, it implies that we can solve any instance of the $\mathrm{SVP}_\gamma$ for $\gamma=O({n^c}),c>1$.</li></ul><p>Therefore, by the previous discussion, we see that the above construction implies an <em>average-case to worst-case reduction</em>. <strong>GGH11</strong><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> later extended the analysis of <strong>Ajtai96</strong> to show that the family of one-way functions is also collision-resistant, which is a stronger and more useful property for cryptographic applications.</p><p>We now define the SIS problem and state a lemma (without proof) of its hardness.</p><h2 id=short-integer-solution-mathrmsis_nmqbeta>Short Integer Solution ($\mathrm{SIS}_{n,m,q,\beta}$)<a hidden class=anchor aria-hidden=true href=#short-integer-solution-mathrmsis_nmqbeta>#</a></h2><blockquote><p>Let $A$ be a <strong>uniformly random matrix</strong> , i.e. , $A=\{a_0| a_1 | \ldots | a_{m-1}\}$
consists of $m$ uniformly random vectors $a_i\in\mathbb{Z}^n_q,i\in[m]$. Find a nontrivial $x\in\mathbb{Z}^m$, s.t. $|x|\leq\beta$ and $Ax\equiv 0\mod{q}$.</p></blockquote><p>Here $A\sim\mathbb{Z}_{q}^{n\times m}$ where $\mathbb{Z}^n_q$ is the set of all $n$-dimensional integer vectors modulo $q$, i.e., $\mathbb{Z}^n_q={\left\langle x_1,\ldots, x_n \right\rangle}$, where $x_i\in{0,1,\ldots,q-1}$ for all $i\in[n]$.</p><p>We also note here that without the constraint $|x|\leq\beta$, the $\mathrm{SIS}$ is easy to solve using <em>Gaussian elimination</em>.</p><h3 id=hardness-of-mathrmsis>Hardness of $\mathrm{SIS}$<a hidden class=anchor aria-hidden=true href=#hardness-of-mathrmsis>#</a></h3><blockquote><p>For any $m = \mathrm{poly}(n)$, any $\beta > 0$, and any sufficiently large $q \geq \beta n^c$ (for any constant $c >0$), solving $\mathrm{SIS}({n,m,q,\beta})$ with nonnegligible probability is at least as hard as
solving $GapSVP_\gamma$ and ${SIVP}_\gamma$ for some $\gamma = \beta \cdot O(\sqrt{n})$ with a high probability in the worst-case scenario.</p></blockquote><p>Now we turn our attention to the construction of <strong>GGH11</strong><sup id=fnref1:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> based on the hardness of $\mathrm{SIS}$.</p><h3 id=a-specific-crhf-construction-ggh11>A specific CRHF construction (GGH11)<a hidden class=anchor aria-hidden=true href=#a-specific-crhf-construction-ggh11>#</a></h3><p>We define a <strong>Collision-Resistant Hash function</strong> (CRHF) as follows:</p><ul><li>Set $m>n\frac{\log{q}}{\log{d}}$.</li><li><strong>Key:</strong> A matrix $A$ chosen uniformly at random from $\mathbb{Z}^{m\times n}_q$.</li><li><strong>Hash function:</strong> Define a <strong>Shrinking function</strong> (shrinking since the domain is greater than the range): $f_A:{0,\ldots, d-1}^m\xrightarrow{}\mathbb{Z}^n_q$ s.t. $f_A(x)=Ax\mod q$.</li><li><strong>Goal:</strong> Find $x,x^{\prime}\in{0,1}^m$ s.t. $f_A(x)=f_A(x^{\prime})$.</li></ul><p>Note that finding a solution to the collision problem yields a solution $z=x-x^\prime$ to the $\mathrm{SIS}$ problem as $0=f_A(x)-f_A(x^{\prime})=Ax-Ax^\prime=Az\equiv 0\mod{q}$.</p><blockquote><p>We now define a class of random lattices known as $q$-ary lattices and connect it to the $\mathrm{SIS}$ problem.</p></blockquote><h2 id=q-ary-lattices-at-last>$q$-ary Lattices at last!<a hidden class=anchor aria-hidden=true href=#q-ary-lattices-at-last>#</a></h2><blockquote><p>Given $A\sim \mathbb{Z}^{n\times m}_q$, $q$-ary lattices $\Lambda_q^\perp(A)$ are defined as
$$\Lambda_q^\perp(A)=\{z\in\mathbb{Z}^m:Az=0\mod{q}\}.$$</p></blockquote><p>We note that the randomness of $\Lambda_q^\perp(A)$ stems from the randomness of $A$ itself. $\Lambda_q^\perp(A)$ contains all vectors that are orthogonal modulo $q$ to the rows of $A$, i.e. $\Lambda_q^\perp(A)$ corresponds to the code whose parity check matrix is $A$.</p><p>Here, we see that we have successfully <strong>characterized a lattice in terms of a parity check matrix</strong> $A$ <em>instead of a basis</em>. The class of $q$-ary lattices is the class of random lattices required in <strong>Lemma 1</strong> and <strong>Theorem 2</strong>. We end this article with another lemma by Ajtai96 and some properties of $q$-ary lattices which connects the average-case hardness guarantees with worst-case guarantees.</p><h3 id=lemma-2-ajtai96>Lemma 2 (Ajtai96)<a hidden class=anchor aria-hidden=true href=#lemma-2-ajtai96>#</a></h3><blockquote><p>Finding short $z\in\Lambda_q^\perp(A)$ s.t. $\left|{z}\right|\leq \beta &lt; q$, implies solving $\mathrm{GapSVP}_{\beta\sqrt{n}}$ on any n-dimensional lattice.</p></blockquote><h3 id=properties-of-q-ary-lattices>Properties of $q$-ary Lattices<a hidden class=anchor aria-hidden=true href=#properties-of-q-ary-lattices>#</a></h3><ul><li>A $q$-ary lattice $L$ satisfies $q\mathbb{Z}^n \subseteq L \subseteq \mathbb{Z}^n$ for $q\in\mathbb{Z}$.</li><li>Any integer lattice $\mathcal{L}\subseteq\mathbb{Z}^n$ is a $q$-ary lattice for some $q$, e.g., whenever q is an integer multiple of the determinant $\mathrm{det}(\mathcal{L})$. We are only interested when $q$ is much smaller than $\left|{\mathrm{det}(L)}\right|$.</li><li>The following two problems are equivalent:<ul><li>Finding a short vector in $\Lambda_q^\perp(A)$ s.t. $A\sim \mathbb{Z}^{n\times m}_q$.</li><li>Finding a short solution to a set of $n$ random equations modulo $q$ in $m$ variables.</li></ul></li><li>The dual of any $q$-ary lattice is also a $q$-ary lattice. We represent the dual of a $q$-ary lattice $\Lambda_q^\perp(A)$ using the notation $\Lambda_q(A)$, which is defined as $$\Lambda_q(A)=\{z\in\mathbb{Z}^m:z=A^Ts\mod{q},,s\in\mathbb{Z}^n\}.$$<ul><li>Here $\Lambda_q(A)$ is the code generated by the rows of $A$, i.e., $A$ itself is the generator matrix of the code. Contrast this with $\Lambda_q^\perp(A)$ where $A$ is the parity check matrix.</li></ul></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><strong>Ajtai96:</strong> M. Ajtai. 1996. Generating hard instances of lattice problems (extended abstract). In Proceedings of the twenty-eighth annual ACM symposium on Theory of Computing (STOC &lsquo;96). Association for Computing Machinery, New York, NY, USA, 99–108. <a href=https://doi.org/10.1145/237814.237838 rel=noopener class=external-link target=_blank>https://doi.org/10.1145/237814.237838
</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref4:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><strong>Shor95:</strong> Peter W. Shor. 1997. Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer. SIAM J. Comput. 26, 5 (Oct. 1997), 1484–1509. <a href=https://doi.org/10.1137/S0097539795293172 rel=noopener class=external-link target=_blank>https://doi.org/10.1137/S0097539795293172
</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><strong>BP23:</strong> Huck Bennett and Chris Peikert. Hardness of the (Approximate) Shortest Vector Problem: A Simple Proof via Reed-Solomon Codes. In Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques (APPROX/RANDOM 2023). Leibniz International Proceedings in Informatics (LIPIcs), Volume 275, pp. 37:1-37:20, Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2023). <a href=https://doi.org/10.4230/LIPIcs.APPROX/RANDOM.2023.37 rel=noopener class=external-link target=_blank>https://doi.org/10.4230/LIPIcs.APPROX/RANDOM.2023.37
</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><strong>BS99:</strong> Johannes Blömer and Jean-Pierre Seifert. On the complexity of computing short linearly independent vectors and short bases in a lattice. In Proceedings of the Thirty-first Annual ACM Symposium on Theory of Computing, STOC ’99, pages 711–720, New York, NY, USA, 1999. ACM.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><strong>Ajtai99:</strong> Miklós Ajtai. 1999. Generating Hard Instances of the Short Basis Problem. In Proceedings of the 26th International Colloquium on Automata, Languages and Programming (ICAL &lsquo;99). Springer-Verlag, Berlin, Heidelberg, 1–9.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><strong>GGH11:</strong> O. Goldreich, S. Goldwasser, and S. Halevi. Collision-free hashing from lattice problems. Studies in Complexity and Cryptography. Miscellanea on the Interplay between Randomness and Computation: In Collaboration with Lidor Avigad, Mihir Bellare, Zvika Brakerski, Shafi Goldwasser, Shai Halevi, Tali Kaufman, Leonid Levin, Noam Nisan, Dana Ron, Madhu Sudan, Luca Trevisan, Salil Vadhan, Avi Wigderson, David Zuckerman, pages 30–39, 2011&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://theoretickles.netlify.app/tags/lattices/>Lattices</a></li><li><a href=https://theoretickles.netlify.app/tags/coding-theory/>Coding Theory</a></li><li><a href=https://theoretickles.netlify.app/tags/cryptography/>Cryptography</a></li></ul><nav class=paginav><a class=next href=https://theoretickles.netlify.app/posts/srcontinued/><span class=title>« Prev</span><br><span>Self-Reducibility (Part 2)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on x" href="https://x.com/intent/tweet/?text=%24q%24-ary%20Lattices&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f&amp;hashtags=lattices%2ccodingtheory%2ccryptography"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f&amp;title=%24q%24-ary%20Lattices&amp;summary=%24q%24-ary%20Lattices&amp;source=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f&title=%24q%24-ary%20Lattices"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on whatsapp" href="https://api.whatsapp.com/send?text=%24q%24-ary%20Lattices%20-%20https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on telegram" href="https://telegram.me/share/url?text=%24q%24-ary%20Lattices&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share $q$-ary Lattices on ycombinator" href="https://news.ycombinator.com/submitlink?t=%24q%24-ary%20Lattices&u=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fqary%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://theoretickles.netlify.app/>Theoretickles</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>