<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Self-Reducibility (Part 1) | Theoretickles</title><meta name=keywords content="reductions,p-np,self-reducibility,search-to-decision,SAT,CLIQUE"><meta name=description content="
This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let&rsquo;s dive in.

Introduction
Preliminaries: Search and Decision Problems
In an earlier post, we familiarised ourselves with the notion of reductions
. Towards the end, we introduced the notion of self-reducibility which is our main topic of focus today. We start by familiarising ourselves with a few concepts."><meta name=author content="Me"><link rel=canonical href=https://theoretickles.netlify.app/posts/selfreductions/><link crossorigin=anonymous href=/assets/css/stylesheet.242f90366e47418aeeb4469f46a06be27f005e2845b0e27a538c5a6d413c453d.css integrity="sha256-JC+QNm5HQYrutEafRqBr4n8AXihFsOJ6U4xabUE8RT0=" rel="preload stylesheet" as=style><link rel=icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://theoretickles.netlify.app/posts/selfreductions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript id=MathJax-script async src=https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://theoretickles.netlify.app/posts/selfreductions/"><meta property="og:site_name" content="Theoretickles"><meta property="og:title" content="Self-Reducibility (Part 1)"><meta property="og:description" content=" This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let’s dive in.
Introduction Preliminaries: Search and Decision Problems In an earlier post, we familiarised ourselves with the notion of reductions. Towards the end, we introduced the notion of self-reducibility which is our main topic of focus today. We start by familiarising ourselves with a few concepts."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-01T11:51:18+05:30"><meta property="article:modified_time" content="2025-02-01T11:51:18+05:30"><meta property="article:tag" content="Reductions"><meta property="article:tag" content="P-Np"><meta property="article:tag" content="Self-Reducibility"><meta property="article:tag" content="Search-to-Decision"><meta property="article:tag" content="SAT"><meta property="article:tag" content="CLIQUE"><meta property="og:image" content="https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Self-Reducibility (Part 1)"><meta name=twitter:description content="
This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let&rsquo;s dive in.

Introduction
Preliminaries: Search and Decision Problems
In an earlier post, we familiarised ourselves with the notion of reductions
. Towards the end, we introduced the notion of self-reducibility which is our main topic of focus today. We start by familiarising ourselves with a few concepts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://theoretickles.netlify.app/posts/"},{"@type":"ListItem","position":2,"name":"Self-Reducibility (Part 1)","item":"https://theoretickles.netlify.app/posts/selfreductions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Self-Reducibility (Part 1)","name":"Self-Reducibility (Part 1)","description":" This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let\u0026rsquo;s dive in.\nIntroduction Preliminaries: Search and Decision Problems In an earlier post, we familiarised ourselves with the notion of reductions\r. Towards the end, we introduced the notion of self-reducibility which is our main topic of focus today. We start by familiarising ourselves with a few concepts.\n","keywords":["reductions","p-np","self-reducibility","search-to-decision","SAT","CLIQUE"],"articleBody":" This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let’s dive in.\nIntroduction Preliminaries: Search and Decision Problems In an earlier post, we familiarised ourselves with the notion of reductions\r. Towards the end, we introduced the notion of self-reducibility which is our main topic of focus today. We start by familiarising ourselves with a few concepts.\nIn the world of complexity and computability, a language is a set of strings formed out of some alphabet. Formally, $L\\subseteq\\Sigma^{*}$, where the alphabet $\\Sigma$ is a finite set of symbols, and $\\Sigma^{*}$ refers to the Kleene closure\rof $\\Sigma$.\nLast time we formalized reductions in terms of Turing Machines\r. We now explicitly define mapping reductions (equivalent to Karp reductions for TMs) in terms of languages. Let $L_1 \\subseteq \\Sigma_1^{*}$ and $L_2 \\subseteq \\Sigma_2^{*}$ be languages. Recall that $L_1\\leq_m L_2$ (or, $L_1$ reduces to $L_2$), if there exists a computable function $f: \\Sigma_1^{*}\\mapsto\\Sigma_2^{*}$ s.t. for every $w\\in\\Sigma_1^{*}$, $w\\in L_1\\iff f(w)\\in L_2$. We sometimes use the notation $A\\leq^p_m B$ to denote that the function $f$ is polynomial time constructible.\nA decision problem is a Boolean-valued function $D:\\Sigma^{*}\\mapsto\\{0,1\\}$. We can view $D$ as a language $L_D = \\{ x\\in\\Sigma^{*} : D(x)=1\\}$. Conversely, every language $L\\subseteq\\Sigma^{*}$ can be uniquely associated with a unique decision problem $D_L$ called the membership problem. Here, $x\\in L\\iff D_L(x)=1$. A Turing machine $T$ computes/solves the decision problem $D$ if for any input $x\\in\\Sigma^{*}$, $T$ halts on any input $x$ and produces output $T(x)=D(x)$.\nRecall that complexity classes P and NP are defined w.r.t. decision problems. $L$ is in P if $\\exists$ an efficient decider for the membership problem of any string in $\\Sigma^{*}$. $L$ is in NP if there exists an efficient verifier and a polynomial sized certificate for the membership problem of any string in $\\Sigma^{*}$.\nIn complexity theory, many problems can be naturally expressed as search problems (for example, TSP, HamCycle, etc.), but are shoehorned into the above model of decision problems in order for us to easily classify them into classes like P and NP.\nSearch Problems: A search problem is a relation $R\\subset\\Sigma_{in}^{*}\\times\\Sigma_{out}^{*}$, i.e., $(x,y)\\in R$, where $x\\in\\Sigma_{in},y\\in\\Sigma_{out}$ are strings belonging to the input and output alphabets respectively. Search problems are also known as relational problems / optimization problems.\nA Turing machine $T$ decides/computes/solves $R$, if for any input $x\\in\\Sigma_{in}$, $T(x)$ halts and produces $y\\in\\Sigma_{out}$ s.t. $(x,y)\\in R$, or correctly states that no such $y$ exists.\nWe remark here that a relation $R\\subset\\Sigma_{in}^{*}\\times\\Sigma_{out}^{*}$ is said to be polynomially-balanced if for any $(x,y)\\in R$, $|y|=\\text{poly}(|x|)$.\nSince the complexity class NP is defined w.r.t. decision problems, we need to introduce an equivalent notion for search problems. Informally, this is denoted by the class FNP (or Function NP). (We make this informal connection explicit shortly.)\nA relation $R$ is polynomially balanced, any $y$ s.t. $(x,y)\\in R$ serves as the certificate/witness for $x$. Formally, a polynomially-balanced relation $R\\in$ FNP (i.e., $R$ is an NP search problem) if $R$ is polynomial-time computable.\nA search problem $R$ is in FP if $R\\in$ FNP and if there exists an efficient decider for $R$.\nNote that FP is analogous to P in the context of search problems. The following theorem cements this analogy.\nFP = FNP iff P = NP.\nSearch-to-Decision reductions Recall that decision problems answer the following flavour of questions:\nGiven a problem $P$, is $x$ a solution to $P$? (Yes/No).\nOn the other hand, search problems answer the following flavour of questions:\nGiven a problem $P$, output a solution to $P$ (preferably with some constraints on the solution).\nFor example, given a problem $P$, output a solution to $P$ that has the minimum length.\nWe use the satisfiability problem (SAT) and its search version (FSAT) as an example to further illustrate the two notions:\nDecision problem: Given a propositional formula $\\phi$, decide if $\\phi$ is satisfiable. (SAT) Search problem: Given a propositional formula $\\phi$, find a satisfying assignment for $\\phi$. (FSAT) It is straightforward to see that if it is easy to solve the Search version of a problem $P$, it is straightforward to solve the Decision version of $P$ (we can easily construct an example / counterexample!). The more challenging question is:\nCan we efficiently solve the Search version of a problem $P$, if we know how to solve the Decision version of $P$ efficiently?\nA problem is self-reducible or auto-reducibile if it admits an efficient search-to-decision reduction, i.e., any efficient solution to the decision version of the problem implies an efficient solution to the search version of the problem.\nIn this section, we see some examples of search-to-decision reductions / self-reducibility. Let us start with designing a search-to-decision reduction using SAT and FSAT, which are NP-complete and FNP-complete problems respectively.\nSearch-to-Decision Reduction for SAT Formally, let $O_D^p$ be a decision oracle for a search problem $R\\subset\\Sigma_{in}^{*}\\times\\Sigma_{out}^{*}$ s.t. querying $O_D^p$ produces $\\mathbb{I}[ \\exists x\\in\\Sigma_{in};|; x \\text{ has property } p]$; i.e., querying $O_D$ with an appropriate parameter for a property $p$ outputs a yes or a no indicating if there exists any input that satisfies the property $p$ (usually taken to be some bound on the input size). Our goal now is to produce $y\\in\\Sigma_{out}$ s.t. $(x,y)\\in R$, using oracle calls to $O_D^p$.\nThere are two inputs to the FSATSearchToDecision() reduction\nthe propositional formula $\\phi$ or f, and the decision oracle for SAT on $O_D$ or DSAT(f,assign) which takes as input a propositional formula f and a restricted assignment assign and returns yes iff f is satisfiable under the restriction assign. The output of the FSATSearchToDecision() procedure is a satisfying assignment for $\\phi$( or f). FSATSearchToDecision(f,DSAT()){ assignarr = [*,*,....,*];// Intitalize assignarr as an n-bit empty array. if(DSAT(f,assignarr)=0) // is f satisfiable without restrictions? return -1; // f is not satisfiable for (i=1;i\u003c=n; i++){ assignarr[i]= 0 //Fix the ith bit in x to be 1. // This fixes the ith literal in f. if (DSAT(f,assignarr)==1) continue; // move on to the i+1th coordinate, // with the ith bit set to 0. assignarr[i]= 1 //Fix the ith bit in x to be 0. // This fixes the ith literal in f. if (DSAT(f,assignarr)==1) continue; // move on to the i+1th coordinate, // with the ith bit set to 1. return assignarr; } Search-to-Decision Reduction for CLIQUE Earlier we saw that the property used by the decision oracle was a restricted assignment. We list another example of a search-to-decision reduction for the Clique problem (another one of Karp’s original 21 NP-complete problems), to give a flavour of a different decision oracle property - based on size.\nThe Clique Decision problem: Given a graph $G=(V,E)$, decide if $G$ contains a clique of size $\\leq k$. The Clique Search problem: Given a graph $G=(V,E)$, find a clique of size $\\leq k$ in $G$ if it exists. As seen above, there are two inputs to the CliqueSearchToDecision() reduction:\nthe graph $G$ as an adjacency list L, and the decision oracle for Clique on $O_D$ or DCLIQUE(L,k) which takes as input a adjacency list L and a parameter k and returns yes iff the graph corresponding to L contains a clique of size at most k. The output of the CliqueSearchToDecision() procedure is an adjacency list corresponding to a clique in $G$ of size $\\leq k$. Recall that an adjacency list is a collection of unordered lists used to represent a finite graph. We use the following definition of adjacency lists (this is a modification of the definition given in CLRS): An adjacency list is a singly linked list where each element in the list corresponds to a particular vertex, and each element in the list itself points to a singly linked list of the neighboring vertices of that vertex. See the diagram below.\nCliqueSearchToDecision(L,DCLIQUE()){ if(DCLIQUE(L,k)=0) return -1; // There is no clique of size at most k for every vertex v of G { Let Lv be the new adjacency list obtained by removing vertex v from G. // easily done using the above datastructure. if(DCLIQUE(Lv,k)=1) L = Lv; // update the graph to reflect G = G-v. } return L; } Downward-self-reducibility A related concept to self-reducibility is the notion of downward-self-reducibility. Broadly speaking, self-reducibility asks the following question:\nCan we solve a search problem $P$ if we can solve $P$ under certain constraints?\nEarlier, we required that the constrained version of the search problem $P$ is simply its decision version. We can now pose the above question, but for softer constraints:\nCan we solve a search problem $P$ where solutions belong to the domain $\\mathcal{D}$, if we can efficiently solve $P$ under $\\mathcal{S}\\subset\\mathcal{D}$?\nThis is still an interesting question, since we note that the optimal solution to $P$ when the domain is restricted to $\\mathcal{S}$ is not guaranteed to be the optimal solution to $P$ w.r.t. the more general domain $\\mathcal{D}$. We now formally introduce the notion of Downward-self-reducibility.\nDownward-self-reduciblility for Search Problems A search problem $R$ is downward-self-reducible (d.s.r) if there is a polynomial time oracle algorithm for $R$ that on input $x \\in \\Sigma^{*}$ makes queries to an $R$-oracle of size strictly less than $|x|$.\nIn other words, a language $L$ is d.s.r. if there exists a polynomial time algorithm $A^O$ deciding $x\\overset{?}{\\in} L$ with a membership oracle $O$ for $L$ that can handle subqueries for strings $z\\overset{?}{\\in} L$ s.t. $|z|\u003c|x|$.\nBefore we dive deeper into this topic, we digress and familiarise ourselves with a similar notion for decision problems - this helps us ask analogous questions, and establish parallels between search and decision versions of downward-self-reducibility.\n\u003c Start of Digression \u003e\nDownward-self-reduciblility for Decision Problems We can extend the notion of downward self-reducibility to functions or decision problems as follows: A function $f:\\Sigma^{*}\\mapsto \\{0,1\\}$ is downward self-reducible if there exists a polynomial time algorithm $A^{O_f}$ s.t. on any input of length $n$, $A$ only makes queries of length $","wordCount":"3034","inLanguage":"en","image":"https://theoretickles.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-01T11:51:18+05:30","dateModified":"2025-02-01T11:51:18+05:30","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://theoretickles.netlify.app/posts/selfreductions/"},"publisher":{"@type":"Organization","name":"Theoretickles","logo":{"@type":"ImageObject","url":"https://theoretickles.netlify.app/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://theoretickles.netlify.app/ accesskey=h title="Theoretickles (Alt + H)"><img src=https://theoretickles.netlify.app/apple-touch-icon.png alt aria-label=logo height=35>Theoretickles</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://theoretickles.netlify.app/categories/ title=categories><span>categories</span></a></li><li><a href=https://theoretickles.netlify.app/tags/ title=tags><span>tags</span></a></li><li><a href=https://chatsagnik.github.io title=chatsagnik><span>chatsagnik</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://theoretickles.netlify.app/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://theoretickles.netlify.app/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://theoretickles.netlify.app/>Home</a>&nbsp;»&nbsp;<a href=https://theoretickles.netlify.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Self-Reducibility (Part 1)</h1><div class=post-meta><span title='2025-02-01 11:51:18 +0530 IST'>February 1, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3034 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/selfreductions.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#preliminaries-search-and-decision-problems aria-label="Preliminaries: Search and Decision Problems">Preliminaries: Search and Decision Problems</a></li></ul></li><li><a href=#search-to-decision-reductions aria-label="Search-to-Decision reductions">Search-to-Decision reductions</a><ul><li><a href=#search-to-decision-reduction-for-sat aria-label="Search-to-Decision Reduction for SAT">Search-to-Decision Reduction for SAT</a></li><li><a href=#search-to-decision-reduction-for-clique aria-label="Search-to-Decision Reduction for CLIQUE">Search-to-Decision Reduction for CLIQUE</a></li></ul></li><li><a href=#downward-self-reducibility aria-label=Downward-self-reducibility>Downward-self-reducibility</a><ul><li><a href=#downward-self-reduciblility-for-search-problems aria-label="Downward-self-reduciblility for Search Problems">Downward-self-reduciblility for Search Problems</a><ul><li><a href=#downward-self-reduciblility-for-decision-problems aria-label="Downward-self-reduciblility for Decision Problems">Downward-self-reduciblility for Decision Problems</a></li><li><a href=#an-application-mahaneys-theorem aria-label="An application: Mahaney&rsquo;s Theorem">An application: Mahaney&rsquo;s Theorem</a></li></ul></li><li><a href=#downward-self-reduciblility-and-self-reducibility-for-search-problems-continued aria-label="Downward-self-reduciblility and Self-reducibility for Search Problems (Continued)">Downward-self-reduciblility and Self-reducibility for Search Problems (Continued)</a></li></ul></li><li><a href=#footnotes aria-label=Footnotes>Footnotes</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p><em>This post assumes basic familiarity with Turing machines, P, NP, NP-completeness, decidability, and undecidability. The reader is referred to the book by Sipser, or the book by Arora and Barak for any formal definitions that have been skipped in this post. Without further ado, let&rsquo;s dive in.</em></p></blockquote><hr><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><h2 id=preliminaries-search-and-decision-problems>Preliminaries: Search and Decision Problems<a hidden class=anchor aria-hidden=true href=#preliminaries-search-and-decision-problems>#</a></h2><p>In an earlier post, we familiarised ourselves with the <a href=https://theoretickles.netlify.app/posts/reductions rel=noopener class=external-link target=_blank>notion of reductions
</a>. Towards the end, we introduced the notion of <strong>self-reducibility</strong> which is our main topic of focus today. We start by familiarising ourselves with a few concepts.</p><p>In the world of complexity and computability, a <em>language</em> is a set of strings formed out of some alphabet. Formally, $L\subseteq\Sigma^{*}$, where the alphabet $\Sigma$ is a finite set of symbols, and $\Sigma^{*}$ refers to the <a href=https://en.wikipedia.org/wiki/Kleene_star#Definition rel=noopener class=external-link target=_blank>Kleene closure
</a>of $\Sigma$.</p><p><a href=https://theoretickles.netlify.app/posts/reductions rel=noopener class=external-link target=_blank>Last time we formalized reductions in terms of Turing Machines
</a>. We now explicitly define mapping reductions (equivalent to Karp reductions for TMs) in terms of languages. Let $L_1 \subseteq \Sigma_1^{*}$ and $L_2 \subseteq \Sigma_2^{*}$ be languages. Recall that $L_1\leq_m L_2$ (or, $L_1$ reduces to $L_2$), if there exists a computable function $f: \Sigma_1^{*}\mapsto\Sigma_2^{*}$ s.t. for every $w\in\Sigma_1^{*}$, $w\in L_1\iff f(w)\in L_2$. We sometimes use the notation $A\leq^p_m B$ to denote that the function $f$ is polynomial time constructible.</p><hr><p>A <strong>decision problem</strong> is a Boolean-valued function $D:\Sigma^{*}\mapsto\{0,1\}$. We can view $D$ as a language $L_D = \{ x\in\Sigma^{*} : D(x)=1\}$. Conversely, every language $L\subseteq\Sigma^{*}$ can be uniquely associated with a unique decision problem $D_L$ called the <strong>membership problem</strong>. Here, $x\in L\iff D_L(x)=1$. A Turing machine $T$ computes/solves the decision problem $D$ if for any input $x\in\Sigma^{*}$, $T$ halts on any input $x$ and produces output $T(x)=D(x)$.</p><p>Recall that complexity classes <strong>P</strong> and <strong>NP</strong> are defined w.r.t. decision problems. $L$ is in <strong>P</strong> if $\exists$ an efficient decider for the membership problem of any string in $\Sigma^{*}$. $L$ is in <strong>NP</strong> if there exists an efficient verifier and a polynomial sized certificate for the membership problem of any string in $\Sigma^{*}$.</p><p>In complexity theory, many problems can be naturally expressed as <strong>search problems</strong> (for example, TSP, HamCycle, etc.), but are shoehorned into the above model of <strong>decision problems</strong> in order for us to easily classify them into classes like <strong>P</strong> and <strong>NP</strong>.</p><hr><p><strong>Search Problems:</strong> A search problem is a relation $R\subset\Sigma_{in}^{*}\times\Sigma_{out}^{*}$, i.e., $(x,y)\in R$, where $x\in\Sigma_{in},y\in\Sigma_{out}$ are strings belonging to the input and output alphabets respectively. Search problems are also known as relational problems / optimization problems.</p><p>A Turing machine $T$ decides/computes/solves $R$, if for any input $x\in\Sigma_{in}$, $T(x)$ halts and produces $y\in\Sigma_{out}$ s.t. $(x,y)\in R$, or correctly states that no such $y$ exists.</p><p>We remark here that a relation $R\subset\Sigma_{in}^{*}\times\Sigma_{out}^{*}$ is said to be polynomially-balanced if for any $(x,y)\in R$, $|y|=\text{poly}(|x|)$.</p><hr><p>Since the complexity class <strong>NP</strong> is defined w.r.t. decision problems, we need to introduce an equivalent notion for search problems. Informally, this is denoted by the class <strong>FNP</strong> (or Function <strong>NP</strong>). (We make this informal connection explicit shortly.)</p><p>A relation $R$ is polynomially balanced, any $y$ s.t. $(x,y)\in R$ serves as the certificate/witness for $x$. Formally, a polynomially-balanced relation $R\in$ <strong>FNP</strong> (i.e., $R$ is an NP search problem) if $R$ is polynomial-time computable.</p><p>A search problem $R$ is in <strong>FP</strong> if $R\in$ <strong>FNP</strong> and if there exists an efficient decider for $R$.</p><p>Note that <strong>FP</strong> is analogous to <strong>P</strong> in the context of search problems. The following theorem cements this analogy.</p><blockquote><p><strong>FP</strong> = <strong>FNP</strong> iff <strong>P</strong> = <strong>NP</strong>.</p></blockquote><hr><h1 id=search-to-decision-reductions>Search-to-Decision reductions<a hidden class=anchor aria-hidden=true href=#search-to-decision-reductions>#</a></h1><p>Recall that decision problems answer the following flavour of questions:</p><blockquote><p>Given a problem $P$, is $x$ a solution to $P$? (Yes/No).</p></blockquote><p>On the other hand, search problems answer the following flavour of questions:</p><blockquote><p>Given a problem $P$, output a solution to $P$ (preferably with some constraints on the solution).</p></blockquote><p>For example, given a problem $P$, output a solution to $P$ that has the minimum length.</p><p>We use the satisfiability problem (<code>SAT</code>) and its search version (<code>FSAT</code>) as an example to further illustrate the two notions:</p><ul><li><strong>Decision problem:</strong> Given a propositional formula $\phi$, decide if $\phi$ is satisfiable. (<code>SAT</code>)</li><li><strong>Search problem:</strong> Given a propositional formula $\phi$, find a satisfying assignment for $\phi$. (<code>FSAT</code>)</li></ul><p>It is straightforward to see that if it is easy to solve the Search version of a problem $P$, it is straightforward to solve the Decision version of $P$ (we can easily construct an example / counterexample!). The more challenging question is:</p><blockquote><p>Can we efficiently solve the Search version of a problem $P$, if we know how to solve the Decision version of $P$ efficiently?</p></blockquote><p>A problem is <strong>self-reducible</strong> or <strong>auto-reducibile</strong> if it admits an efficient search-to-decision reduction, i.e., any efficient solution to the decision version of the problem implies an efficient solution to the search version of the problem.</p><p>In this section, we see some examples of search-to-decision reductions / self-reducibility. Let us start with designing a search-to-decision reduction using <code>SAT</code> and <code>FSAT</code>, which are <strong>NP-complete</strong> and <strong>FNP-complete</strong> problems respectively.</p><h2 id=search-to-decision-reduction-for-sat>Search-to-Decision Reduction for SAT<a hidden class=anchor aria-hidden=true href=#search-to-decision-reduction-for-sat>#</a></h2><p>Formally, let $O_D^p$ be a decision oracle for a search problem $R\subset\Sigma_{in}^{*}\times\Sigma_{out}^{*}$ s.t. querying $O_D^p$ produces $\mathbb{I}[ \exists x\in\Sigma_{in};|; x \text{ has property } p]$; i.e., querying $O_D$ with an appropriate parameter for a <em>property</em> $p$ outputs a yes or a no indicating if there exists any input that satisfies the property $p$ (usually taken to be some bound on the input size). Our goal now is to produce $y\in\Sigma_{out}$ s.t. $(x,y)\in R$, using oracle calls to $O_D^p$.</p><p>There are two inputs to the <code>FSATSearchToDecision()</code> reduction</p><ul><li>the propositional formula $\phi$ or <code>f</code>, and</li><li>the decision oracle for SAT on $O_D$ or <code>DSAT(f,assign)</code> which takes as input a propositional formula <code>f</code> and a restricted assignment <code>assign</code> and returns yes iff <code>f</code> is satisfiable under the restriction <code>assign</code>. The output of the <code>FSATSearchToDecision()</code> procedure is a satisfying assignment for $\phi$( or <code>f</code>).</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>FSATSearchToDecision</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=nf>DSAT</span><span class=p>()){</span>
</span></span><span class=line><span class=cl>    <span class=n>assignarr</span> <span class=o>=</span> <span class=p>[</span><span class=o>*</span><span class=p>,</span><span class=o>*</span><span class=p>,....,</span><span class=o>*</span><span class=p>];</span><span class=c1>// Intitalize assignarr as an n-bit empty array.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=nf>DSAT</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=n>assignarr</span><span class=p>)</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// is f satisfiable without restrictions?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// f is not satisfiable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>assignarr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Fix the ith bit in x to be 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// This fixes the ith literal in f.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>DSAT</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=n>assignarr</span><span class=p>)</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// move on to the i+1th coordinate,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// with the ith bit set to 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assignarr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Fix the ith bit in x to be 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// This fixes the ith literal in f.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>DSAT</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=n>assignarr</span><span class=p>)</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// move on to the i+1th coordinate,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// with the ith bit set to 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>assignarr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=search-to-decision-reduction-for-clique>Search-to-Decision Reduction for CLIQUE<a hidden class=anchor aria-hidden=true href=#search-to-decision-reduction-for-clique>#</a></h2><p>Earlier we saw that the property used by the decision oracle was a restricted assignment. We list another example of a search-to-decision reduction for the Clique problem (another one of Karp&rsquo;s original 21 <strong>NP-complete</strong> problems), to give a flavour of a different decision oracle property - based on size.</p><ul><li><strong>The Clique Decision problem:</strong> Given a graph $G=(V,E)$, decide if $G$ contains a clique of size $\leq k$.</li><li><strong>The Clique Search problem:</strong> Given a graph $G=(V,E)$, find a clique of size $\leq k$ in $G$ if it exists.</li></ul><p>As seen above, there are two inputs to the <code>CliqueSearchToDecision()</code> reduction:</p><ul><li>the graph $G$ as an adjacency list <code>L</code>, and</li><li>the decision oracle for Clique on $O_D$ or <code>DCLIQUE(L,k)</code> which takes as input a adjacency list <code>L</code> and a parameter <code>k</code> and returns yes iff the graph corresponding to <code>L</code> contains a clique of size at most <code>k</code>. The output of the <code>CliqueSearchToDecision()</code> procedure is an adjacency list corresponding to a clique in $G$ of size $\leq k$.</li></ul><blockquote><p>Recall that an adjacency list is a collection of unordered lists used to represent a finite graph. We use the following definition of adjacency lists (this is a modification of the definition given in CLRS): An adjacency list is a singly linked list where each element in the list corresponds to a particular vertex, and each element in the list itself points to a singly linked list of the neighboring vertices of that vertex. See the diagram below.</p></blockquote><p><img alt="Adjacency List" loading=lazy src=/posts/adjacency_list.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>CliqueSearchToDecision</span><span class=p>(</span><span class=n>L</span><span class=p>,</span><span class=nf>DCLIQUE</span><span class=p>()){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>DCLIQUE</span><span class=p>(</span><span class=n>L</span><span class=p>,</span><span class=n>k</span><span class=p>)</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// There is no clique of size at most k
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=n>every</span> <span class=n>vertex</span> <span class=n>v</span> <span class=n>of</span> <span class=n>G</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Let</span> <span class=n>Lv</span> <span class=n>be</span> <span class=n>the</span> <span class=n>new</span> <span class=n>adjacency</span> <span class=n>list</span>
</span></span><span class=line><span class=cl>        <span class=n>obtained</span> <span class=n>by</span> <span class=n>removing</span> <span class=n>vertex</span> <span class=n>v</span> <span class=n>from</span> <span class=n>G</span><span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=c1>// easily done using the above datastructure.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=nf>DCLIQUE</span><span class=p>(</span><span class=n>Lv</span><span class=p>,</span><span class=n>k</span><span class=p>)</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>L</span> <span class=o>=</span> <span class=n>Lv</span><span class=p>;</span> <span class=c1>// update the graph to reflect G = G-v.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h1 id=downward-self-reducibility>Downward-self-reducibility<a hidden class=anchor aria-hidden=true href=#downward-self-reducibility>#</a></h1><p>A related concept to self-reducibility is the notion of downward-self-reducibility. Broadly speaking, self-reducibility asks the following question:</p><blockquote><p>Can we solve a search problem $P$ if we can solve $P$ under certain constraints?</p></blockquote><p>Earlier, we required that the constrained version of the search problem $P$ is simply its decision version. We can now pose the above question, but for softer constraints:</p><blockquote><p>Can we solve a search problem $P$ where solutions belong to the domain $\mathcal{D}$, if we can efficiently solve $P$ under $\mathcal{S}\subset\mathcal{D}$?</p></blockquote><p>This is still an interesting question, since we note that the optimal solution to $P$ when the domain is restricted to $\mathcal{S}$ is not guaranteed to be the optimal solution to $P$ w.r.t. the more general domain $\mathcal{D}$. We now formally introduce the notion of Downward-self-reducibility.</p><h2 id=downward-self-reduciblility-for-search-problems>Downward-self-reduciblility for Search Problems<a hidden class=anchor aria-hidden=true href=#downward-self-reduciblility-for-search-problems>#</a></h2><p>A search problem $R$ is <strong>downward-self-reducible</strong> (d.s.r) if there is a polynomial time oracle algorithm for $R$ that on input $x \in \Sigma^{*}$ makes queries to an $R$-oracle of size strictly less than $|x|$.</p><p>In other words, a language $L$ is <em>d.s.r.</em> if there exists a polynomial time algorithm $A^O$ deciding $x\overset{?}{\in} L$ with a membership oracle $O$ for $L$ that can handle subqueries for strings $z\overset{?}{\in} L$ s.t. $|z|&lt;|x|$.</p><p>Before we dive deeper into this topic, we digress and familiarise ourselves with a similar notion for decision problems - this helps us ask analogous questions, and establish parallels between search and decision versions of downward-self-reducibility.</p><hr><p><strong>&lt; Start of Digression ></strong></p><h3 id=downward-self-reduciblility-for-decision-problems>Downward-self-reduciblility for Decision Problems<a hidden class=anchor aria-hidden=true href=#downward-self-reduciblility-for-decision-problems>#</a></h3><p>We can extend the notion of downward self-reducibility to <em>functions</em> or decision problems as follows: A function $f:\Sigma^{*}\mapsto \{0,1\}$ is downward self-reducible if there exists a polynomial time algorithm $A^{O_f}$ s.t. on any input of length $n$, $A$ only makes queries of length $&lt;n$ to the membership oracle ${O_f}$, and for every input $x$, $A^{O_f}(x)=f(x)$.</p><p>It is easy to see that SAT is <em>d.s.r.</em> (in the decisional sense) since given any formula $\phi$ on $n$-variables, one can consider only querying on restrictions of $\phi$ to figure out if $\phi$ is satisfiable. Note that <code>FSAT</code> can be shown to be <em>d.s.r.</em> (in the search sense) by using the downward-self-reducibility of <code>SAT</code>.</p><blockquote><p>All <strong>NP-complete</strong> decision problems are downward-self-reducible.</p></blockquote><p><em>Proof Sketch.</em> First we show that <code>SAT</code> is d.s.r. This is easy to do since using a construction similar to the above construction that showed <code>FSAT</code> to be self-reducible. For any arbitrary <strong>NP-complete</strong> problem, we now use the fact there exists a polynomial-time reduction from $L$ to <code>SAT</code>. $\square$</p><blockquote><p>Are all problems in <strong>NP</strong> (not necessarily complete) downward-self-reducible?</p></blockquote><p>Again, suprisingly the answer to this question is not known to be true!! While the answer is known to be true for problems in <strong>P</strong> and all <strong>NP-complete</strong> problems, there are certain barriers to showing that the answer to the above question is true.</p><p>In fact, any answer to this question seems to have deep connections with <a href=https://www.cs.ucdavis.edu/~rogaway/classes/220/winter06/ladner-theorem.pdf rel=noopener class=external-link target=_blank>Ladner&rsquo;s Theorem
</a>which posits the existence of the <strong>NPI</strong> (<strong>NP</strong>-intermediate) class if <strong>P</strong>$\neq$<strong>NP</strong>.</p><p>We shall dwell on this question in more detail in the <a href=https://theoretickles.netlify.app/posts/srcontinued rel=noopener class=external-link target=_blank>next post
</a>. For now, we briefly turn our attention <em>away</em> from the <strong>P</strong>-<strong>NP</strong> hierarchy and onto larger complexity classes. We know that the polynomial hierarchy is not known to have complete problems (this would have serious complexity theoretic implications<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>), but we know that every level in PH admits complete problems.</p><blockquote><p>For any arbitrary $k$, consider any problem $L$ that is complete for the $k$th level of the Polynomial Hierarchy. Is $L$ is downward-self-reducible?</p></blockquote><p>While the answer is known to be true for natural complete problems such as Quantified Boolean Formulas, the question seems to be open in full generality<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. What about problems beyond the Polynomial Hierarchy? How high can we go before we encounter a barrier to downward-self-reducibility?</p><blockquote><p>Every downward self-reducible decision problem is in <strong>PSPACE</strong>.</p></blockquote><p><em>Proof.</em> Let the input to a <em>d.s.r.</em> problem $f$ be $x$. Then any algorithm $A$ that solves $f$ will make queries to some oracle and recursively compute the answer to each query. The depth of the recursion is at most |x|, and at each level of recursion, the algorithm needs to remember the state which requires space at most poly(|x|). This last point holds because the basic computation runs in polynomial time, and hence polynomial space. $\square$</p><p>Recall that <strong>PSPACE</strong> is closed <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> under Karp-reductions. Since, all <em>d.s.r.</em> languages belong to <strong>PSPACE</strong>, we can conclude that <strong>PSPACE</strong> is <strong>hard</strong> in any sense (for example, worst-case or average-case) if and only iff a <em>d.s.r.</em> language is <strong>hard</strong> in the same sense.</p><h3 id=an-application-mahaneys-theorem>An application: Mahaney&rsquo;s Theorem<a hidden class=anchor aria-hidden=true href=#an-application-mahaneys-theorem>#</a></h3><p>A language $L$ is (polynomially) <strong>sparse</strong> if it the number of strings of length $n$ in $L$ is bounded by a polynomial in $n$.</p><blockquote><p><strong>[Mahaney&rsquo;s Theorem]</strong> Assuming <strong>P</strong> $\neq$ <strong>NP</strong>, there are no sparse <strong>NP-complete</strong> languages.</p></blockquote><p><em>Proof Sketch:</em> Recall the d.s.r tree of SAT. Given a SAT formula $\phi[x_1,\ldots,x_n]$ at the first level we can restrict the formula to $\phi_0[0,\ldots,x_n]$ and $\phi_1[1,\ldots,x_n]$. If $\phi$ is satisfiable, then at least one of $\phi_0$ or $\phi_1$ is satisfiable. Hence, at the $\ell$th level, at least one of the $2^{\ell}$ formulas have to be satisfiable for the original formula to be satisifable. If $L$ is a sparse NP-complete language, we have $SAT\leq^p_m L$. Hence, using a mapping reduction from SAT to $L$, we can prune the <em>d.s.r.</em> tree s.t. at the $\ell$th level to only contend with $\text{poly}(\ell)$ formulas. This straightforwarly yields a polynomial time SAT algorithm, since there are only $n$ levels. This violates the <a href=https://en.wikipedia.org/wiki/Exponential_time_hypothesis rel=noopener class=external-link target=_blank>Exponential Time Hypothesis
</a>, and therefore there does not exist any $L$ that is both sparse and NP-complete.</p><p>The above proof sketch is due to Joshua Grochow<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, who credits Manindra Agrawal for the original idea. See Oded Goldreich&rsquo;s <a href=https://www.wisdom.weizmann.ac.il/~oded/MC/208.html rel=noopener class=external-link target=_blank>comments here
</a>. Due to the lack of formatting in the above linked blog (and for my own archival purposes), I reproduce his comments <em>as-is</em> below.</p><blockquote><p><strong>Oded&rsquo;s comments:</strong>
The proof is indeed simple, not any harder than the proof that assumes that the sparse set is a subset of a set in P (see Exercise 3.12 in my computational complexity book).</p><p>The first idea is to scan the downwards self-reducibility tree of SAT and extend at most polynomially many viable vertices at each level of the tree, where this polynomial is determined by the polynomials of the sparseness bound and the stretch of the Karp-reduction (of SAT to the sparse set). The crucial idea is the following: Rather than testing the the residual formulae at the current level by applying the Karp-reduction to each of them, one applies the Karp-reduction to the disjunction of the first formula (i.e., $\phi_1$) and each of the remaining formulae (i.e, the $\phi_i$&rsquo;s for $i>1$).</p><p>The point is that if all reduction values are distinct, then one of these values is not in the sparse set, and it follows that the first formula is not in SAT, and so the first formula can be discarded. Otherewise, if the reduction maps $\phi_1\vee\phi_i$ and $\phi_1\vee\phi_i$ to the same value, then we can discard (say) $\phi_i$, since either $\phi_1$ is in SAT (and remains viable) or $\phi_1$ is not in SAT and so $\phi_i$ and $\phi_j$ have the same SAT-value (and so it suffices to keep either of them).</p></blockquote><p><strong>&lt; End of Digression ></strong></p><hr><h2 id=downward-self-reduciblility-and-self-reducibility-for-search-problems-continued>Downward-self-reduciblility and Self-reducibility for Search Problems (Continued)<a hidden class=anchor aria-hidden=true href=#downward-self-reduciblility-and-self-reducibility-for-search-problems-continued>#</a></h2><p>Earlier we saw that all <strong>NP-complete</strong> decision problems are downward self-reducible. We also saw a notion of equivalence between the complexity classes <strong>P</strong>$\leftrightarrow$<strong>FP</strong> and <strong>NP</strong>$\leftrightarrow$<strong>FNP</strong>. Therefore, a natural question to ask is as follows:</p><blockquote><p>Are all <strong>FNP-complete</strong> problems downward-self-reducible?</p></blockquote><p>Surprisingly, the answer to this question is not straightforward unlike its decisional version!</p><p>Consider any $(x,y)\in R$, where $R\in$<strong>FNP</strong>. Unlike the decision version where $y$ is either $0$ or $1$, here the output string $y$ may not necessarily have a structure that lends itself to <em>variable fixing</em> or <em>structural recursion</em>, <strong>even if $x$ does!</strong>.</p><blockquote><p>On this note, one might ask for a characterization of search problems that are downward-self-reducible? Once again, the answer to this question is discussed in detail in the <a href=https://theoretickles.netlify.app/posts/srcontinued rel=noopener class=external-link target=_blank>next post
</a>.</p></blockquote><p>Since downward-self-reducibility seems to be untenable for search problems, we turn our attention to self-reducibility for search problems. In that same vein, one might be tempted to raise the following question:</p><blockquote><p>Is every problem in <strong>FNP</strong> self-reducible?</p></blockquote><p>In other words, if a search problem admits efficiently verifiable solutions, does it admit efficient search-to-decision reductions?</p><p>At first glance, this question might make sense since we are no longer worried about the structure of the output string, at least on the surface! Above, we saw examples of <strong>NP/FNP-complete</strong> problems admitting efficient search-to-decision reductions where both the search and decision verions are computationally hard. On the other hand, <code>Maximum Matching</code> and <code>Shortest Path</code> are problems where both the search and decision versions are computationally easy, and hence admit efficiently constructible search-to-decision reductions by definition.</p><p>Since these two categories of problems (<strong>P</strong>$\leftrightarrow$<strong>FP</strong> and <strong>NP</strong>$\leftrightarrow$<strong>FNP</strong>) are very different from a computational perspective, and seem to have covered both extremes of search and decision problems, we can ask if this implies that there exists an efficiently constructible search-to-decision reduction for every problem that can be efficiently verified?</p><p>Surprisingly (or not) that answer is no! While, some problems have naturally equivalent notions of search and decision problems, for others <strong>search and decision problems may not be computationally equivalent</strong>. This brings us to the following question:</p><blockquote><p>Which search problems are (not) known to be self-reducible?</p></blockquote><p>We try to answer this question in our <a href=https://theoretickles.netlify.app/posts/srcontinued rel=noopener class=external-link target=_blank>next post
</a>.
<strong>Minor spoiler alert:</strong> A completely unconditional answer is a major open question.</p><hr><h1 id=footnotes>Footnotes<a hidden class=anchor aria-hidden=true href=#footnotes>#</a></h1><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>See <a href=https://math.stackexchange.com/a/168921/120548 rel=noopener class=external-link target=_blank>this StackExchange answer
</a>, and <a href=https://gilkalai.wordpress.com/2010/11/17/aaronson-and-arkhipovs-result-on-hierarchy-collapse/ rel=noopener class=external-link target=_blank>this blog post by Gil Kalai on the Aaronson-Arkhipov result
</a>. <strong>Bonus:</strong> See <a href=https://www.scottaaronson.com/writings/phcollapse.pdf rel=noopener class=external-link target=_blank>this satirical writeup by Scott Aaronson
</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I am personally unaware of an answer to this question. Please reach out to me if you have any resources that address / even discuss this question and I will be happy to add it to the blog (with credits).&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>We recall the notion of <a href=https://theoretickles.netlify.app/posts/reductions#completeness rel=noopener class=external-link target=_blank>notion of complete problems
</a>here.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://arxiv.org/pdf/1610.05825 rel=noopener class=external-link target=_blank>See this preprint
</a>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://theoretickles.netlify.app/tags/reductions/>Reductions</a></li><li><a href=https://theoretickles.netlify.app/tags/p-np/>P-Np</a></li><li><a href=https://theoretickles.netlify.app/tags/self-reducibility/>Self-Reducibility</a></li><li><a href=https://theoretickles.netlify.app/tags/search-to-decision/>Search-to-Decision</a></li><li><a href=https://theoretickles.netlify.app/tags/sat/>SAT</a></li><li><a href=https://theoretickles.netlify.app/tags/clique/>CLIQUE</a></li></ul><nav class=paginav><a class=next href=https://theoretickles.netlify.app/posts/reductions/><span class=title>« Prev</span><br><span>An Introduction to Reductions</span>
</a><a class=prev href=https://theoretickles.netlify.app/posts/srcontinued/><span class=title>Next »</span><br><span>Self-Reducibility (Part 2)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on x" href="https://x.com/intent/tweet/?text=Self-Reducibility%20%28Part%201%29&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f&amp;hashtags=reductions%2cp-np%2cself-reducibility%2csearch-to-decision%2cSAT%2cCLIQUE"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f&amp;title=Self-Reducibility%20%28Part%201%29&amp;summary=Self-Reducibility%20%28Part%201%29&amp;source=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f&title=Self-Reducibility%20%28Part%201%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on whatsapp" href="https://api.whatsapp.com/send?text=Self-Reducibility%20%28Part%201%29%20-%20https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on telegram" href="https://telegram.me/share/url?text=Self-Reducibility%20%28Part%201%29&amp;url=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Self-Reducibility (Part 1) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Self-Reducibility%20%28Part%201%29&u=https%3a%2f%2ftheoretickles.netlify.app%2fposts%2fselfreductions%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://theoretickles.netlify.app/>Theoretickles</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>